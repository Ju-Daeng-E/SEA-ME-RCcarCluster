#!/usr/bin/env python3
"""
BMW PiRacer Integrated Control System - GPIO Speed Optimized
BMW F-Series Í∏∞Ïñ¥ Î†àÎ≤Ñ + PiRacer Ï†úÏñ¥ + PyQt5 GUI ÌÜµÌï© ÏãúÏä§ÌÖú (GPIO18 ÏÜçÎèÑ ÏûÖÎ†•)

Í∏∞Îä•:
- BMW Í∏∞Ïñ¥Î¥âÏúºÎ°ú Í∏∞Ïñ¥ Ï†úÏñ¥ (P/R/N/D/M1-M8)
- Í≤åÏûÑÌå®ÎìúÎ°ú Ïä§Î°úÌãÄ/Ïä§Ìã∞Ïñ¥ÎßÅ Ï†úÏñ¥
- Ïã§ÏãúÍ∞Ñ ÏÜçÎèÑ ÌëúÏãú (GPIO16 ÌïÄ ÏûÖÎ†•)
- PyQt5 GUI ÎåÄÏãúÎ≥¥Îìú
- CAN ÎåÄÏã† GPIO16ÏóêÏÑú ÏßÅÏ†ë ÏÜçÎèÑ Îç∞Ïù¥ÌÑ∞ ÏàòÏã†

ÏµúÏ†ÅÌôî ÏÇ¨Ìï≠:
- GPIO16 ÌïÄÏóêÏÑú ÏßÅÏ†ë ÏÜçÎèÑ ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞
- CAN ÏÜçÎèÑ Î≤ÑÏä§ Ï†úÍ±∞, BMW CANÎßå ÏÇ¨Ïö©
- ÌÉÄÏûÖ ÌûåÌä∏ Ï∂îÍ∞ÄÎ°ú ÏΩîÎìú ÏïàÏ†ïÏÑ± Ìñ•ÏÉÅ
- ÏÉÅÏàòÎ•º ÌÅ¥ÎûòÏä§ ÏÉÅÎã®ÏúºÎ°ú Ïù¥Îèô
- Ï∫êÏã±ÏùÑ ÌÜµÌïú CRC Í≥ÑÏÇ∞ ÏµúÏ†ÅÌôî
- Î°úÍ∑∏ Î†àÎ≤® ÏãúÏä§ÌÖú ÎèÑÏûÖ
- ÏòàÏô∏ Ï≤òÎ¶¨ Í∞úÏÑ†
- ÏΩîÎìú Ï§ëÎ≥µ Ï†úÍ±∞ Î∞è Î©îÏÑúÎìú Î∂ÑÎ¶¨
- ÏÑ±Îä• ÏµúÏ†ÅÌôî (ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞ Ï°∞Ï†ï)
"""

import sys
import os
import can
import time
import threading
import crccheck
import logging
import RPi.GPIO as GPIO
from datetime import datetime
from typing import Optional, Dict, Any, Tuple, Callable
from dataclasses import dataclass
from enum import Enum
from multiprocessing import Process, Value, Array

# PyQt5 import (ÏÑ†ÌÉùÏ†Å)
try:
    from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, 
                               QHBoxLayout, QLabel, QFrame, QTextEdit, QGridLayout,
                               QGroupBox, QPushButton, QProgressBar)
    from PyQt5.QtCore import QTimer, Qt, pyqtSignal, QObject
    from PyQt5.QtGui import QPainter, QPen, QBrush, QColor, QFont, QPixmap
    PYQT5_AVAILABLE = True
    print("‚úÖ PyQt5 successfully imported - GUI enabled")
except ImportError as e:
    print(f"‚ö†Ô∏è PyQt5 ÎùºÏù¥Î∏åÎü¨Î¶¨Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: {e}")
    print("GUI ÏóÜÏù¥ Ïã§ÌñâÎê©ÎãàÎã§. PyQt5 ÏÑ§Ïπò: pip install PyQt5")
    PYQT5_AVAILABLE = False
    
    # Mock classes for when PyQt5 is not available
    class QObject:
        pass
    class QMainWindow:
        def __init__(self): pass
        def show(self): pass
        def setWindowTitle(self, title): pass
        def setGeometry(self, x, y, w, h): pass
        def showFullScreen(self): pass
        def setStyleSheet(self, style): pass
        def setCentralWidget(self, widget): pass
        def closeEvent(self, event): pass
    class QWidget:
        def __init__(self): pass
        def setLayout(self, layout): pass
        def setMinimumSize(self, w, h): pass
        def setMaximumSize(self, w, h): pass
        def update(self): pass
        def width(self): return 100
        def height(self): return 100
        def rect(self): return type('MockRect', (), {'adjusted': lambda *args: self})()
        def paintEvent(self, event): pass
    class QApplication:
        def __init__(self, args): pass
        def exec_(self): return 0
    class QVBoxLayout:
        def __init__(self): pass
        def addWidget(self, widget, stretch=0): pass
        def addLayout(self, layout, stretch=0): pass
        def addStretch(self): pass
    class QHBoxLayout:
        def __init__(self): pass
        def addWidget(self, widget, stretch=0): pass
        def addLayout(self, layout, stretch=0): pass
    class QLabel:
        def __init__(self, text=""):
            self.text = text
        def setText(self, text): self.text = text
        def setFont(self, font): pass
        def setAlignment(self, alignment): pass
        def setStyleSheet(self, style): pass
    class QGroupBox:
        def __init__(self, title=""): pass
        def setLayout(self, layout): pass
    class QTextEdit:
        def __init__(self): pass
        def setMaximumHeight(self, h): pass
        def setFont(self, font): pass
        def append(self, text): pass
        def clear(self): pass
        def document(self): return type('MockDoc', (), {'blockCount': lambda: 10})()
        def textCursor(self): return type('MockCursor', (), {
            'movePosition': lambda pos: None,
            'select': lambda sel: None,
            'removeSelectedText': lambda: None,
            'Start': 0, 'BlockUnderCursor': 0
        })()
    class QPushButton:
        def __init__(self, text=""): pass
        def clicked(self): return type('MockSignal', (), {'connect': lambda func: None})()
    class QProgressBar:
        def __init__(self): pass
        def setRange(self, min_val, max_val): pass
        def setValue(self, val): pass
    class QTimer:
        def __init__(self): pass
        def timeout(self): return type('MockSignal', (), {'connect': lambda func: None})()
        def start(self, interval): pass
    class QFont:
        def __init__(self, name, size=10, weight=50): pass
        Bold = 75
    class QPainter:
        def __init__(self, widget): pass
        def setRenderHint(self, hint): pass
        def fillRect(self, rect, color): pass
        def setPen(self, pen): pass
        def drawRoundedRect(self, rect, rx, ry): pass
        def drawEllipse(self, x, y, w, h): pass
        def setFont(self, font): pass
        def drawText(self, rect, alignment, text): pass
        Antialiasing = 1
    class QPen:
        def __init__(self, color, width=1): pass
    class QColor:
        def __init__(self, *args): pass
    class Qt:
        AlignCenter = 0x0084
        AlignRight = 0x0002
    class pyqtSignal:
        def __init__(self, *args): pass
        def emit(self, *args): pass
        def connect(self, func): pass

# PiRacer Î∞è Í≤åÏûÑÌå®Îìú import (ÏÉÅÏÑ∏ ÎîîÎ≤ÑÍπÖ Ìè¨Ìï®)
print("üîç Starting PiRacer library import...")
print(f"üìÅ Current working directory: {os.getcwd()}")
print(f"üêç Python executable: {sys.executable}")

try:
    print("üîç Attempting to import piracer module...")
    import piracer
    print(f"‚úÖ piracer module found at: {piracer.__file__}")
    
    print("üîç Importing PiRacerStandard...")
    from piracer.vehicles import PiRacerStandard
    print("‚úÖ PiRacerStandard import successful")
    
    print("üîç Importing ShanWanGamepad...")
    from piracer.gamepads import ShanWanGamepad
    print("‚úÖ ShanWanGamepad import successful")
    
    PIRACER_AVAILABLE = True
    GAMEPAD_CLASS = ShanWanGamepad  # Ï†ÑÏó≠ Î≥ÄÏàòÎ°ú Ï†ÄÏû•
    print("‚úÖ All PiRacer imports successful - PIRACER_AVAILABLE = True")
    
except ImportError as e:
    print(f"‚ùå PiRacer import failed: {e}")
    print(f"üîç Import error type: {type(e).__name__}")
    import traceback
    print(f"üìã Import traceback:\n{traceback.format_exc()}")
    print("‚ö†Ô∏è ÏãúÎÆ¨Î†àÏù¥ÏÖò Î™®ÎìúÎ°ú Ïã§ÌñâÎê©ÎãàÎã§.")
    
    PIRACER_AVAILABLE = False
    PiRacerStandard = None
    GAMEPAD_CLASS = None  # import Ïã§Ìå®Ïãú NoneÏúºÎ°ú ÏÑ§Ï†ï
    
print(f"üìä Final PIRACER_AVAILABLE status: {PIRACER_AVAILABLE}")
print(f"üìä Final GAMEPAD_CLASS status: {GAMEPAD_CLASS is not None}")

# ÏÉÅÏàò Ï†ïÏùò
class Constants:
    # CAN Í¥ÄÎ†®
    BMW_CAN_CHANNEL = 'can0'
    CAN_BITRATE = 500000
    LEVER_MESSAGE_ID = 0x197
    LED_MESSAGE_ID = 0x3FD
    HEARTBEAT_MESSAGE_ID = 0x55e
    
    # ÏÜçÎèÑÏÑºÏÑú Í¥ÄÎ†® (GPIO) 
    SPEED_SENSOR_PIN = 16  # GPIO 16 (Physical Pin 36)
    PULSES_PER_TURN = 40  # encoder wheel: 20 slots √ó 2 (rising+falling)
    WHEEL_DIAMETER_MM = 64  # mm
    
    # ÌÉÄÏù¥Î∞ç
    BMW_CAN_TIMEOUT = 1.0
    GAMEPAD_UPDATE_RATE = 20  # Hz
    LED_UPDATE_RATE = 10  # Hz
    TIME_UPDATE_RATE = 1  # Hz
    TOGGLE_TIMEOUT = 0.5
    SPEED_CALCULATION_INTERVAL = 1.0  # ÏÜçÎèÑ Í≥ÑÏÇ∞ Í∞ÑÍ≤© (Ï¥à)
    PULSE_DEBOUNCE_MICROS = 700  # ÌéÑÏä§ ÎîîÎ∞îÏö¥Ïã± ÎßàÏù¥ÌÅ¨Î°úÏ¥à
    
    # UI Í¥ÄÎ†® (1280x400 ÏµúÏ†ÅÌôî)
    WINDOW_WIDTH = 1280
    WINDOW_HEIGHT = 400
    MAX_LOG_LINES = 30
    LOG_FONT_SIZE = 7
    SPEEDOMETER_SIZE = (100, 100)
    GEAR_DISPLAY_SIZE = (100, 80)
    
    # ÏÑ±Îä• Í¥ÄÎ†®
    MAX_SPEED = 50.0  # km/h
    SPEED_GEARS = 4
    MANUAL_GEARS = 8
    
    # ÏÉâÏÉÅ
    BMW_BLUE = "#0078d4"
    SUCCESS_GREEN = "#00ff00"
    ERROR_RED = "#ff0000"
    WARNING_ORANGE = "#ff8800"

class GearType(Enum):
    """Í∏∞Ïñ¥ ÌÉÄÏûÖ Ïó¥Í±∞Ìòï"""
    PARK = 'P'
    REVERSE = 'R'
    NEUTRAL = 'N'
    DRIVE = 'D'
    SPORT = 'S'
    MANUAL = 'M'
    UNKNOWN = 'Unknown'

class LeverPosition(Enum):
    """Î†àÎ≤Ñ ÏúÑÏπò Ïó¥Í±∞Ìòï"""
    CENTER = 0x0E
    UP_R = 0x1E
    UP_PLUS = 0x2E
    DOWN_D = 0x3E
    SIDE_S = 0x7E
    MANUAL_DOWN = 0x5E
    MANUAL_UP = 0x6E

@dataclass
class BMWState:
    """BMW ÏÉÅÌÉú Îç∞Ïù¥ÌÑ∞ ÌÅ¥ÎûòÏä§"""
    current_gear: str = 'D'  # Ï¥àÍ∏∞Í∞íÏùÑ DÎ°ú Î≥ÄÍ≤Ω (ÌÖåÏä§Ìä∏Ïö©)
    manual_gear: int = 1
    lever_position: str = 'Unknown'
    park_button: str = 'Released'
    unlock_button: str = 'Released'
    last_update: Optional[str] = None

@dataclass
class PiRacerState:
    """PiRacer ÏÉÅÌÉú Îç∞Ïù¥ÌÑ∞ ÌÅ¥ÎûòÏä§"""
    throttle_input: float = 0.0
    steering_input: float = 0.0
    current_speed: float = 0.0
    speed_gear: int = 1

# BMW CRC ÌÅ¥ÎûòÏä§Îì§ (Ï∫êÏã± ÏµúÏ†ÅÌôî)
class BMW3FDCRC(crccheck.crc.Crc8Base):
    _poly = 0x1D
    _initvalue = 0x0
    _xor_output = 0x70

class BMW197CRC(crccheck.crc.Crc8Base):
    _poly = 0x1D
    _initvalue = 0x0
    _xor_output = 0x53

class CRCCalculator:
    """CRC Í≥ÑÏÇ∞ÏùÑ ÏúÑÌïú Ï∫êÏã± ÌÅ¥ÎûòÏä§"""
    def __init__(self):
        self._cache_3fd = {}
        self._cache_197 = {}
    
    def bmw_3fd_crc(self, message: bytes) -> int:
        """BMW 3FD CRC Í≥ÑÏÇ∞ (Ï∫êÏã±)"""
        message_bytes = bytes(message) if not isinstance(message, bytes) else message
        if message_bytes not in self._cache_3fd:
            self._cache_3fd[message_bytes] = BMW3FDCRC.calc(message_bytes) & 0xFF
        return self._cache_3fd[message_bytes]
    
    def bmw_197_crc(self, message: bytes) -> int:
        """BMW 197 CRC Í≥ÑÏÇ∞ (Ï∫êÏã±)"""
        message_bytes = bytes(message) if not isinstance(message, bytes) else message
        if message_bytes not in self._cache_197:
            self._cache_197[message_bytes] = BMW197CRC.calc(message_bytes) & 0xFF
        return self._cache_197[message_bytes]

class LogLevel(Enum):
    """Î°úÍ∑∏ Î†àÎ≤®"""
    DEBUG = 0
    INFO = 1
    WARNING = 2
    ERROR = 3

class FileLogHandler:
    """ÌååÏùº Î°úÍ∑∏ Ìï∏Îì§Îü¨ ÌÅ¥ÎûòÏä§"""
    def __init__(self, log_dir: str = "logs"):
        self.log_dir = log_dir
        
        # Î°úÍ∑∏ ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
        try:
            os.makedirs(self.log_dir, exist_ok=True)
        except Exception as e:
            print(f"‚ö†Ô∏è Failed to create log directory: {e}")
        
        # ÏÑ∏ÏÖòÎ≥Ñ Î°úÍ∑∏ ÌååÏùºÎ™Ö ÏÉùÏÑ± (ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.log_filename = os.path.join(self.log_dir, f"bmw_controller_{timestamp}.log")
        
        # Î°úÍ∑∏ ÌååÏùº Ï¥àÍ∏∞Ìôî
        try:
            with open(self.log_filename, 'w', encoding='utf-8') as f:
                f.write(f"BMW PiRacer Controller Log - Session started at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write("=" * 80 + "\n\n")
            print(f"üìù Log file created: {self.log_filename}")
        except Exception as e:
            print(f"‚ùå Failed to create log file: {e}")
            self.log_filename = None
    
    def write_log(self, message: str):
        """Î°úÍ∑∏ Î©îÏãúÏßÄÎ•º ÌååÏùºÏóê Í∏∞Î°ù"""
        if not self.log_filename:
            return
            
        try:
            with open(self.log_filename, 'a', encoding='utf-8') as f:
                f.write(f"{message}\n")
                f.flush()  # Ï¶âÏãú ÎîîÏä§ÌÅ¨Ïóê Í∏∞Î°ù
        except Exception as e:
            print(f"‚ùå Failed to write log: {e}")
    
    def cleanup_old_logs(self, max_files: int = 10):
        """Ïò§ÎûòÎêú Î°úÍ∑∏ ÌååÏùº Ï†ïÎ¶¨ (ÏµúÎåÄ Í∞úÏàò Ïú†ÏßÄ)"""
        try:
            log_files = []
            for filename in os.listdir(self.log_dir):
                if filename.startswith("bmw_controller_") and filename.endswith(".log"):
                    filepath = os.path.join(self.log_dir, filename)
                    mtime = os.path.getmtime(filepath)
                    log_files.append((mtime, filepath))
            
            # ÏãúÍ∞ÑÏàú Ï†ïÎ†¨ (Ïò§ÎûòÎêú Í≤ÉÎ∂ÄÌÑ∞)
            log_files.sort()
            
            # ÏµúÎåÄ Í∞úÏàò Ï¥àÍ≥ºÏãú Ïò§ÎûòÎêú ÌååÏùº ÏÇ≠Ï†ú
            if len(log_files) > max_files:
                files_to_delete = log_files[:-max_files]
                for _, filepath in files_to_delete:
                    os.remove(filepath)
                    print(f"üóëÔ∏è Removed old log file: {os.path.basename(filepath)}")
        except Exception as e:
            print(f"‚ö†Ô∏è Failed to cleanup old logs: {e}")

class Logger:
    """Ïª§Ïä§ÌÖÄ Î°úÍ±∞ ÌÅ¥ÎûòÏä§ (ÌååÏùº Î°úÍπÖ ÏßÄÏõê)"""
    def __init__(self, level: LogLevel = LogLevel.INFO, enable_file_logging: bool = True):
        self.level = level
        self.handlers = []
        
        # ÌååÏùº Î°úÍπÖ ÏÑ§Ï†ï
        self.file_handler = None
        if enable_file_logging:
            try:
                self.file_handler = FileLogHandler()
                self.file_handler.cleanup_old_logs()
                print(f"‚úÖ File logging enabled: {self.file_handler.log_filename}")
            except Exception as e:
                print(f"‚ö†Ô∏è File logging disabled due to error: {e}")
                self.file_handler = None
    
    def add_handler(self, handler: Callable[[str], None]):
        """Î°úÍ∑∏ Ìï∏Îì§Îü¨ Ï∂îÍ∞Ä"""
        self.handlers.append(handler)
    
    def log(self, level: LogLevel, message: str):
        """Î°úÍ∑∏ Î©îÏãúÏßÄ Ï∂úÎ†•"""
        if level.value >= self.level.value:
            timestamp = datetime.now().strftime("[%H:%M:%S]")
            full_timestamp = datetime.now().strftime("[%Y-%m-%d %H:%M:%S]")
            
            # ÏΩòÏÜîÏö© Î©îÏãúÏßÄ (ÏßßÏùÄ ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ)
            console_msg = f"{timestamp} {message}"
            
            # ÌååÏùºÏö© Î©îÏãúÏßÄ (Í∏¥ ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ, Î†àÎ≤® Ìè¨Ìï®)
            level_name = level.name.ljust(7)  # 7ÏûêÎ¶¨Î°ú ÎßûÏ∂§
            file_msg = f"{full_timestamp} [{level_name}] {message}"
            
            # ÏΩòÏÜî Ìï∏Îì§Îü¨Îì§ÏóêÍ≤å Ï†ÑÏÜ°
            for handler in self.handlers:
                handler(console_msg)
            
            # ÌååÏùºÏóê Í∏∞Î°ù
            if self.file_handler:
                self.file_handler.write_log(file_msg)
    
    def debug(self, message: str):
        self.log(LogLevel.DEBUG, f"üîç {message}")
    
    def info(self, message: str):
        self.log(LogLevel.INFO, f"‚ÑπÔ∏è {message}")
    
    def warning(self, message: str):
        self.log(LogLevel.WARNING, f"‚ö†Ô∏è {message}")
    
    def error(self, message: str):
        self.log(LogLevel.ERROR, f"‚ùå {message}")
    
    def critical(self, message: str):
        """ÏπòÎ™ÖÏ†Å ÏóêÎü¨ Î°úÍ∑∏ (Ìï≠ÏÉÅ Í∏∞Î°ù)"""
        timestamp = datetime.now().strftime("[%Y-%m-%d %H:%M:%S]")
        critical_msg = f"{timestamp} [CRITICAL] üö® {message}"
        
        # ÏΩòÏÜîÏóê Ï∂úÎ†• (Î†àÎ≤® Î¨¥Ïãú)
        print(critical_msg)
        
        # ÌååÏùºÏóê Í∏∞Î°ù
        if self.file_handler:
            self.file_handler.write_log(critical_msg)
        
        # Î™®Îì† Ìï∏Îì§Îü¨ÏóêÍ≤å Ï†ÑÏÜ°
        for handler in self.handlers:
            handler(critical_msg)
    
    def get_log_filename(self) -> Optional[str]:
        """ÌòÑÏû¨ Î°úÍ∑∏ ÌååÏùºÎ™Ö Î∞òÌôò"""
        return self.file_handler.log_filename if self.file_handler else None

class SpeedSensor:
    """ÏÜçÎèÑÏÑºÏÑú GPIO Ï†úÏñ¥ ÌÅ¥ÎûòÏä§"""
    
    def __init__(self, logger: Logger, speed_callback: Callable[[float], None]):
        self.logger = logger
        self.speed_callback = speed_callback
        self.counter = 0
        self.velocity_kmh = 0.0
        self.previous_micros = 0
        self.running = False
        self.calculation_thread = None
        
        # GPIO ÏÑ§Ï†ï (Ìè¥ÎßÅ Î∞©Ïãù)
        try:
            GPIO.cleanup()  # Í∏∞Ï°¥ ÏÑ§Ï†ï Ï†ïÎ¶¨
        except:
            pass
            
        try:
            GPIO.setmode(GPIO.BCM)
            GPIO.setup(Constants.SPEED_SENSOR_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)
            self.logger.info(f"‚úì Speed sensor initialized on GPIO {Constants.SPEED_SENSOR_PIN} (polling mode)")
        except Exception as e:
            self.logger.error(f"Speed sensor GPIO setup failed: {e}")
    
    def _count_pulses_polling(self):
        """Ìè¥ÎßÅ Î∞©Ïãù ÌéÑÏä§ Ïπ¥Ïö¥Ìä∏"""
        current_state = GPIO.input(Constants.SPEED_SENSOR_PIN)
        current_micros = time.time() * 1000000  # microseconds
        
        # Ïù¥Ï†Ñ ÏÉÅÌÉúÏôÄ Îã§Î•¥Î©¥ ÏóêÏßÄ Í∞êÏßÄ
        if hasattr(self, 'last_state') and current_state != self.last_state:
            if current_micros - self.previous_micros >= Constants.PULSE_DEBOUNCE_MICROS:
                self.counter += 1
                self.previous_micros = current_micros
                
        self.last_state = current_state
    
    def _calculate_speed(self):
        """ÏÜçÎèÑ Í≥ÑÏÇ∞ Ïä§Î†àÎìú (Ìè¥ÎßÅ Î∞©Ïãù)"""
        try:
            self.last_state = GPIO.input(Constants.SPEED_SENSOR_PIN)  # Ï¥àÍ∏∞ ÏÉÅÌÉú
        except:
            self.last_state = 1  # Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
        
        while self.running:
            try:
                # Ìè¥ÎßÅÏúºÎ°ú ÌéÑÏä§ Í∞êÏßÄ (1ms Í∞ÑÍ≤©)
                for _ in range(int(Constants.SPEED_CALCULATION_INTERVAL * 1000)):
                    if not self.running:
                        break
                    self._count_pulses_polling()
                    time.sleep(0.001)  # 1ms Ìè¥ÎßÅ
                
                # RPM Í≥ÑÏÇ∞
                rpm = (60 * self.counter) / Constants.PULSES_PER_TURN
                
                # Î∞îÌÄ¥ ÎëòÎûò (m)
                wheel_circ_m = 3.1416 * (Constants.WHEEL_DIAMETER_MM / 1000.0)
                
                # ÏÜçÎèÑ (km/h)
                self.velocity_kmh = (rpm * wheel_circ_m * 60) / 1000.0
                
                # ÏÜçÎèÑ ÏóÖÎç∞Ïù¥Ìä∏ ÏΩúÎ∞±
                self.speed_callback(self.velocity_kmh)
                
                # ÎîîÎ≤ÑÍ∑∏ Î°úÍ∑∏
                if self.counter > 0:  # Ïù¥Îèô Ï§ëÏùº ÎïåÎßå Î°úÍ∑∏
                    self.logger.debug(f"üèÅ RPM: {rpm:.1f} | Speed: {self.velocity_kmh:.2f} km/h | Pulses: {self.counter}")
                
                # Ïπ¥Ïö¥ÌÑ∞ Î¶¨ÏÖã
                self.counter = 0
                
            except Exception as e:
                self.logger.error(f"Speed calculation error: {e}")
                time.sleep(1)
    
    def start(self):
        """ÏÜçÎèÑ Í≥ÑÏÇ∞ ÏãúÏûë"""
        if not self.running:
            self.running = True
            self.calculation_thread = threading.Thread(target=self._calculate_speed, daemon=True)
            self.calculation_thread.start()
            self.logger.info("üü¢ Speed sensor started")
    
    def stop(self):
        """ÏÜçÎèÑ Í≥ÑÏÇ∞ Ï§ëÎã®"""
        self.running = False
        self.logger.info("üî¥ Speed sensor stopped (polling mode)")
    
    def cleanup(self):
        """Ï†ïÎ¶¨"""
        self.stop()
        try:
            GPIO.cleanup(Constants.SPEED_SENSOR_PIN)
        except Exception as e:
            self.logger.error(f"GPIO cleanup error: {e}")

class SignalEmitter(QObject):
    """ÏãúÍ∑∏ÎÑê Î∞©Ï∂úÏö© ÌÅ¥ÎûòÏä§"""
    gear_changed = pyqtSignal(str)
    lever_changed = pyqtSignal(str)
    button_changed = pyqtSignal(str, str)
    can_status_changed = pyqtSignal(bool)
    message_received = pyqtSignal(str)
    debug_info = pyqtSignal(str)
    stats_updated = pyqtSignal(int)
    speed_updated = pyqtSignal(float)
    piracer_status_changed = pyqtSignal(str)

class SpeedometerWidget(QWidget):
    """ÏÜçÎèÑÍ≥Ñ ÌëúÏãú ÏúÑÏ†Ø - ÏµúÏ†ÅÌôîÎê®"""
    
    def __init__(self):
        super().__init__()
        self.current_speed = 0.0
        self.max_speed = Constants.MAX_SPEED
        self.setMinimumSize(*Constants.SPEEDOMETER_SIZE)
        
        # ÏÉâÏÉÅ Ï∫êÏã±
        self.bg_color = QColor(20, 20, 20)
        self.border_color = QColor(0, 120, 215)
        self.speed_color = QColor(0, 255, 100)
        self.text_color = QColor(255, 255, 255)
        self.circle_color = QColor(100, 100, 100)
        
    def set_speed(self, speed: float):
        """ÏÜçÎèÑ ÏÑ§Ï†ï"""
        new_speed = max(0, min(speed, self.max_speed))
        if abs(self.current_speed - new_speed) > 0.1:  # ÏûëÏùÄ Î≥ÄÌôîÎäî Î¨¥Ïãú
            self.current_speed = new_speed
            # QTimerÎ•º ÏÇ¨Ïö©ÌïòÏó¨ ÏïàÏ†ÑÌïú ÏóÖÎç∞Ïù¥Ìä∏
            QTimer.singleShot(50, self.update)  # 50ms ÏßÄÏó∞ÏúºÎ°ú ÏïàÏ†ÑÌïú ÏóÖÎç∞Ïù¥Ìä∏
        
    def paintEvent(self, event):
        try:
            painter = QPainter(self)
            if not painter.isActive():
                return
            painter.setRenderHint(QPainter.Antialiasing)
            
            # Î∞∞Í≤Ω
            painter.fillRect(self.rect(), self.bg_color)
            
            # ÌÖåÎëêÎ¶¨
            painter.setPen(QPen(self.border_color, 3))
            painter.drawRoundedRect(self.rect().adjusted(5, 5, -5, -5), 15, 15)
            
            # ÏÜçÎèÑÍ≥Ñ Ïõê
            center_x = self.width() // 2
            center_y = self.height() // 2
            radius = min(self.width(), self.height()) // 2 - 20
            
            painter.setPen(QPen(self.circle_color, 2))
            painter.drawEllipse(center_x - radius, center_y - radius, radius * 2, radius * 2)
            
            # ÏÜçÎèÑ ÌÖçÏä§Ìä∏
            painter.setPen(QPen(self.speed_color))
            font = QFont("Arial", 24, QFont.Bold)
            painter.setFont(font)
            
            speed_text = f"{self.current_speed:.1f}"
            text_rect = self.rect().adjusted(0, -20, 0, 0)
            painter.drawText(text_rect, Qt.AlignCenter, speed_text)
            
            # Îã®ÏúÑ
            painter.setPen(QPen(self.text_color))
            font = QFont("Arial", 12)
            painter.setFont(font)
            unit_rect = self.rect().adjusted(0, 25, 0, 0)
            painter.drawText(unit_rect, Qt.AlignCenter, "km/h")
            
            painter.end()
            
        except Exception as e:
            print(f"‚ùå Speedometer paint error: {e}")

class GearDisplayWidget(QWidget):
    """ÌòÑÏû¨ Í∏∞Ïñ¥ ÏÉÅÌÉú ÌëúÏãú ÏúÑÏ†Ø - ÏµúÏ†ÅÌôîÎê®"""
    
    def __init__(self):
        super().__init__()
        self.current_gear = 'Unknown'
        self.manual_gear = 1
        self.setMinimumSize(*Constants.GEAR_DISPLAY_SIZE)
        
        # ÏÉâÏÉÅ Îß§Ìïë Ï∫êÏã±
        self.gear_colors = {
            'P': QColor(255, 100, 100),    # Îπ®Í∞ÑÏÉâ
            'R': QColor(255, 140, 0),      # Ï£ºÌô©ÏÉâ
            'N': QColor(255, 255, 100),    # ÎÖ∏ÎûÄÏÉâ
            'D': QColor(100, 255, 100),    # ÎÖπÏÉâ
            'M': QColor(100, 150, 255),    # ÌååÎûÄÏÉâ
            'Unknown': QColor(150, 150, 150)  # ÌöåÏÉâ
        }
        
        self.status_texts = {
            'P': "PARK",
            'R': "REVERSE", 
            'N': "NEUTRAL",
            'D': "DRIVE",
            'M': lambda gear: f"MANUAL {gear}",
            'Unknown': "UNKNOWN"
        }
        
    def set_gear(self, gear: str, manual_gear: int = 1):
        """Í∏∞Ïñ¥ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏"""
        if self.current_gear != gear or self.manual_gear != manual_gear:
            self.current_gear = gear
            self.manual_gear = manual_gear
            # QTimerÎ•º ÏÇ¨Ïö©ÌïòÏó¨ ÏïàÏ†ÑÌïú ÏóÖÎç∞Ïù¥Ìä∏
            QTimer.singleShot(50, self.update)  # 50ms ÏßÄÏó∞ÏúºÎ°ú ÏïàÏ†ÑÌïú ÏóÖÎç∞Ïù¥Ìä∏
        
    def paintEvent(self, event):
        try:
            painter = QPainter(self)
            if not painter.isActive():
                return
            painter.setRenderHint(QPainter.Antialiasing)
            
            # Î∞∞Í≤Ω
            painter.fillRect(self.rect(), QColor(20, 20, 20))
            
            # ÌÖåÎëêÎ¶¨
            painter.setPen(QPen(QColor(0, 120, 215), 3))
            painter.drawRoundedRect(self.rect().adjusted(5, 5, -5, -5), 15, 15)
            
            # Í∏∞Ïñ¥Î≥Ñ ÏÉâÏÉÅ Î∞è ÏÉÅÌÉú ÌÖçÏä§Ìä∏
            gear_key = self.current_gear[0] if self.current_gear.startswith('M') else self.current_gear
            color = self.gear_colors.get(gear_key, self.gear_colors['Unknown'])
            
            if self.current_gear.startswith('M'):
                status_text = self.status_texts['M'](self.manual_gear)
            else:
                status_text = self.status_texts.get(self.current_gear, "UNKNOWN")
            
            # Í∏∞Ïñ¥ ÌëúÏãú
            painter.setPen(QPen(color))
            font = QFont("Arial", 36, QFont.Bold)
            painter.setFont(font)
            
            gear_rect = self.rect().adjusted(0, -20, 0, 0)
            painter.drawText(gear_rect, Qt.AlignCenter, self.current_gear)
            
            # ÏÉÅÌÉú ÌÖçÏä§Ìä∏
            painter.setPen(QPen(QColor(255, 255, 255)))
            font = QFont("Arial", 10)
            painter.setFont(font)
            status_rect = self.rect().adjusted(0, 30, 0, 0)
            painter.drawText(status_rect, Qt.AlignCenter, status_text)
            
            painter.end()
            
        except Exception as e:
            print(f"‚ùå Gear display paint error: {e}")

class BMWLeverController:
    """BMW Î†àÎ≤Ñ Ï†úÏñ¥ Î°úÏßÅÏùÑ Î∂ÑÎ¶¨Ìïú ÌÅ¥ÎûòÏä§"""
    
    def __init__(self, logger: Logger):
        self.logger = logger
        self.lever_position_map = {
            0x0E: 'Center',
            0x1E: 'Up (R)', 
            0x2E: 'Up+ (Beyond R)',
            0x3E: 'Down (D)',
            0x7E: 'Side (S)',
            0x5E: 'Manual Down (-)',
            0x6E: 'Manual Up (+)'
        }
        
        # ÌÜ†Í∏Ä Ï†úÏñ¥ Î≥ÄÏàòÎì§
        self.current_lever_position = 0x0E
        self.previous_lever_position = 0x0E
        self.lever_returned_to_center = True
        self.lever_returned_to_manual_center = True
        self.last_toggle_time = 0
        
    def decode_lever_message(self, msg: can.Message, bmw_state: BMWState) -> bool:
        """Î†àÎ≤Ñ Î©îÏãúÏßÄ ÎîîÏΩîÎî©"""
        if len(msg.data) < 4:
            return False
            
        try:
            crc = msg.data[0]
            counter = msg.data[1]
            lever_pos = msg.data[2]
            park_btn = msg.data[3]
            
            # Î†àÎ≤Ñ ÏúÑÏπò Îß§Ìïë
            bmw_state.lever_position = self.lever_position_map.get(
                lever_pos, f'Unknown (0x{lever_pos:02X})'
            )
            
            # Î≤ÑÌäº ÏÉÅÌÉú
            bmw_state.park_button = 'Pressed' if (park_btn & 0x01) != 0 else 'Released'
            bmw_state.unlock_button = 'Pressed' if (park_btn & 0x02) != 0 else 'Released'
            
            # ÌÜ†Í∏Ä Ï≤òÎ¶¨
            self.previous_lever_position = self.current_lever_position
            self.current_lever_position = lever_pos
            self._handle_toggle_action(lever_pos, park_btn, bmw_state)
            
            bmw_state.last_update = datetime.now().strftime("%H:%M:%S")
            return True
            
        except Exception as e:
            self.logger.error(f"Lever message decode error: {e}")
            return False
    
    def _handle_toggle_action(self, lever_pos: int, park_btn: int, bmw_state: BMWState):
        """ÌÜ†Í∏Ä Î∞©Ïãù Í∏∞Ïñ¥ Ï†ÑÌôò Ï≤òÎ¶¨"""
        current_time = time.time()
        unlock_pressed = (park_btn & 0x02) != 0
        
        # Unlock Î≤ÑÌäº Ï≤òÎ¶¨
        if unlock_pressed and bmw_state.current_gear == 'P' and lever_pos == 0x0E:
            bmw_state.current_gear = 'N'
            self.logger.info("üîì Unlock: PARK ‚Üí NEUTRAL")
            return
        
        # Park Î≤ÑÌäº Ï≤òÎ¶¨
        if (park_btn & 0x01) != 0 and lever_pos == 0x0E:
            bmw_state.current_gear = 'P'
            self.logger.info("üÖøÔ∏è Park Button ‚Üí PARK")
            return
        
        # ÌÜ†Í∏Ä ÌÉÄÏûÑÏïÑÏõÉ Ï≤¥ÌÅ¨
        if current_time - self.last_toggle_time < Constants.TOGGLE_TIMEOUT:
            return
        
        # ÏÑºÌÑ∞ Î≥µÍ∑Ä ÌÜ†Í∏Ä Ï≤òÎ¶¨
        if lever_pos == 0x0E and not self.lever_returned_to_center:
            self.lever_returned_to_center = True
            self._process_toggle_transition(bmw_state)
            self.last_toggle_time = current_time
        elif lever_pos != 0x0E:
            self.lever_returned_to_center = False

        # ÏàòÎèô ÏÑºÌÑ∞ Î≥µÍ∑Ä ÌÜ†Í∏Ä Ï≤òÎ¶¨
        if lever_pos == 0x7E and not self.lever_returned_to_manual_center:
            self.lever_returned_to_manual_center = True
            self._process_toggle_manual_transition(bmw_state)
            self.last_toggle_time = current_time
        elif lever_pos != 0x7E:
            self.lever_returned_to_manual_center = False
    
    def _process_toggle_transition(self, bmw_state: BMWState):
        """ÌÜ†Í∏Ä Ï†ÑÌôò Ï≤òÎ¶¨"""
        transitions = {
            0x1E: self._handle_up_toggle,      # UP
            0x2E: lambda bs: self._set_gear(bs, 'P', "üéØ UP+ ‚Üí PARK"),  # UP+
            0x3E: self._handle_down_toggle,    # DOWN
            0x7E: self._handle_side_toggle,    # SIDE
        }
        
        handler = transitions.get(self.previous_lever_position)
        if handler:
            handler(bmw_state)
    
    def _process_toggle_manual_transition(self, bmw_state: BMWState):
        """ÏàòÎèô ÌÜ†Í∏Ä Ï†ÑÌôò Ï≤òÎ¶¨"""
        transitions = {
            0x5E: self._handle_manual_down_toggle,  # Manual Down
            0x6E: self._handle_manual_up_toggle,    # Manual Up
            0x0E: self._handle_side_toggle,         # Center ‚Üí Side
        }
        
        handler = transitions.get(self.previous_lever_position)
        if handler:
            handler(bmw_state)
    
    def _handle_up_toggle(self, bmw_state: BMWState):
        """ÏúÑ ÌÜ†Í∏Ä Ï≤òÎ¶¨"""
        gear_transitions = {
            'N': ('R', "üéØ N ‚Üí REVERSE"),
            'D': ('N', "üéØ D ‚Üí NEUTRAL"),
        }
        
        new_gear, msg = gear_transitions.get(bmw_state.current_gear, ('N', "üéØ UP ‚Üí NEUTRAL"))
        self._set_gear(bmw_state, new_gear, msg)
    
    def _handle_down_toggle(self, bmw_state: BMWState):
        """ÏïÑÎûò ÌÜ†Í∏Ä Ï≤òÎ¶¨"""
        gear_transitions = {
            'N': ('D', "üéØ N ‚Üí DRIVE"),
            'R': ('N', "üéØ R ‚Üí NEUTRAL"),
        }
        
        new_gear, msg = gear_transitions.get(bmw_state.current_gear, ('D', "üéØ DOWN ‚Üí DRIVE"))
        self._set_gear(bmw_state, new_gear, msg)
    
    def _handle_side_toggle(self, bmw_state: BMWState):
        """ÏÇ¨Ïù¥Îìú ÌÜ†Í∏Ä Ï≤òÎ¶¨"""
        if bmw_state.current_gear == 'D':
            bmw_state.manual_gear = 1
            self._set_gear(bmw_state, f'M{bmw_state.manual_gear}', f"üéØ D ‚Üí MANUAL M{bmw_state.manual_gear}")
        elif bmw_state.current_gear.startswith('M'):
            self._set_gear(bmw_state, 'D', "üéØ Manual ‚Üí DRIVE")
        else:
            self._set_gear(bmw_state, 'D', "üéØ SIDE ‚Üí DRIVE")
    
    def _handle_manual_up_toggle(self, bmw_state: BMWState):
        """ÏàòÎèô ÏóÖ ÌÜ†Í∏Ä Ï≤òÎ¶¨"""
        if bmw_state.current_gear.startswith('M') and bmw_state.manual_gear < Constants.MANUAL_GEARS:
            bmw_state.manual_gear += 1
            self._set_gear(bmw_state, f'M{bmw_state.manual_gear}', f"üîº Manual ‚Üí M{bmw_state.manual_gear}")
    
    def _handle_manual_down_toggle(self, bmw_state: BMWState):
        """ÏàòÎèô Îã§Ïö¥ ÌÜ†Í∏Ä Ï≤òÎ¶¨"""
        if bmw_state.current_gear.startswith('M') and bmw_state.manual_gear > 1:
            bmw_state.manual_gear -= 1
            self._set_gear(bmw_state, f'M{bmw_state.manual_gear}', f"üîΩ Manual ‚Üí M{bmw_state.manual_gear}")
    
    def _set_gear(self, bmw_state: BMWState, gear: str, message: str):
        """Í∏∞Ïñ¥ ÏÑ§Ï†ï Ìó¨Ìçº Î©îÏÑúÎìú"""
        bmw_state.current_gear = gear
        self.logger.info(message)

class CANController:
    """CAN Î≤ÑÏä§ Ï†úÏñ¥Î•º Îã¥ÎãπÌïòÎäî ÌÅ¥ÎûòÏä§"""
    
    def __init__(self, logger: Logger):
        self.logger = logger
        self.bmw_bus: Optional[can.interface.Bus] = None
        self.running = True
        self.crc_calc = CRCCalculator()
        self.gws_counter = 0x01
        
    def setup_can_interfaces(self) -> bool:
        """CAN Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ ÏÑ§Ï†ï"""
        bmw_ok = self._setup_single_can(Constants.BMW_CAN_CHANNEL, "BMW")
        return bmw_ok
    
    def _setup_single_can(self, channel: str, name: str) -> bool:
        """Îã®Ïùº CAN Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ ÏÑ§Ï†ï"""
        try:
            bus = can.interface.Bus(channel=channel, interface='socketcan')
            self.bmw_bus = bus
            self.logger.info(f"‚úì {name} CAN connected ({channel})")
            return True
        except Exception as e:
            self.logger.warning(f"‚ö† {name} CAN not available: {e}")
            return False
    
    def send_gear_led(self, gear: str, flash: bool = False):
        """Í∏∞Ïñ¥ LED Ï†ÑÏÜ° (ÏµúÏ†ÅÌôîÎê®)"""
        if not self.bmw_bus:
            return
        
        gear_led_codes = {
            'P': 0x20, 'R': 0x40, 'N': 0x60, 'D': 0x80, 'S': 0x81,
        }
        
        # LED ÏΩîÎìú Í≤∞Ï†ï
        if gear.startswith('M'):
            led_code = 0x81
        elif gear in gear_led_codes:
            led_code = gear_led_codes[gear]
        else:
            return
        
        try:
            self.gws_counter = (self.gws_counter + 1) if self.gws_counter < 0x0E else 0x01
            payload_without_crc = [self.gws_counter, led_code, 0x00, 0x00]
            crc = self.crc_calc.bmw_3fd_crc(payload_without_crc)
            payload = [crc] + payload_without_crc
            
            message = can.Message(
                arbitration_id=Constants.LED_MESSAGE_ID,
                data=payload,
                is_extended_id=False
            )
            
            self.bmw_bus.send(message)
        except Exception as e:
            self.logger.error(f"LED send error: {e}")
    
    def shutdown(self):
        """CAN Î≤ÑÏä§ Ï¢ÖÎ£å"""
        self.running = False
        if self.bmw_bus:
            self.bmw_bus.shutdown()

class BMWPiRacerIntegratedControl(QMainWindow):
    """BMW PiRacer ÌÜµÌï© Ï†úÏñ¥ ÏãúÏä§ÌÖú GUI - ÏµúÏ†ÅÌôîÎê®"""
    
    def __init__(self):
        super().__init__()
        self._init_system()
        self._init_ui()
        self._setup_connections()
        self._start_control_loops()
        
    def _init_system(self):
        """ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî"""
        # Î°úÍ±∞ ÏÑ§Ï†ï (ÌååÏùº Î°úÍπÖ ÌôúÏÑ±Ìôî)
        self.logger = Logger(LogLevel.INFO, enable_file_logging=True)
        
        # Î°úÍ∑∏ ÌååÏùº Ï†ïÎ≥¥ Ï∂úÎ†•
        log_filename = self.logger.get_log_filename()
        if log_filename:
            print(f"üìù Session log file: {log_filename}")
        else:
            print("‚ö†Ô∏è File logging disabled")
        
        # ÏãúÍ∑∏ÎÑê Ï¥àÍ∏∞Ìôî
        self.signals = SignalEmitter()
        
        # ÏÉÅÌÉú Í∞ùÏ≤¥Îì§
        self.bmw_state = BMWState()
        self.piracer_state = PiRacerState()
        
        # Ïª®Ìä∏Î°§Îü¨Îì§
        self.lever_controller = BMWLeverController(self.logger)
        self.can_controller = CANController(self.logger)
        self.speed_sensor = SpeedSensor(self.logger, self._on_speed_updated)
        
        # ÌÜµÍ≥Ñ
        self.message_count = 0
        self.running = True
        
        # PiRacer Ï¥àÍ∏∞Ìôî
        self.piracer = None
        self.gamepad = None
        
        self.logger.info("üöÄ Starting PiRacer and Gamepad initialization...")
        self.logger.info(f"üìä PIRACER_AVAILABLE status: {PIRACER_AVAILABLE}")
        self.logger.info(f"üìä GAMEPAD_CLASS available: {GAMEPAD_CLASS is not None}")
        
        if PIRACER_AVAILABLE:
            self.logger.info("üì¶ PiRacer library is available, proceeding with initialization...")
            
            # PiRacer Ï¥àÍ∏∞Ìôî
            try:
                self.logger.info("üèéÔ∏è Initializing PiRacer hardware...")
                self.piracer = PiRacerStandard()
                self.logger.info("‚úÖ PiRacer hardware initialized successfully")
                
            except Exception as e:
                self.logger.error(f"‚ùå PiRacer hardware initialization failed: {e}")
                self.logger.error(f"üîç Error type: {type(e).__name__}")
                self.piracer = None
                self.signals.piracer_status_changed.emit(f"PiRacer Error: {e}")
            
            # Í≤åÏûÑÌå®Îìú Ï¥àÍ∏∞Ìôî (PiRacerÏôÄ ÎèÖÎ¶ΩÏ†ÅÏúºÎ°ú)
            self.logger.info("üéÆ Starting gamepad initialization (independent of PiRacer)...")
            self._initialize_gamepad_with_debug()
                    
        else:
            self.logger.warning("‚ö†Ô∏è PiRacer library not available - running in simulation mode")
            self.logger.info("üìä Checking gamepad availability without PiRacer...")
            
            # PiRacer ÏóÜÏñ¥ÎèÑ Í≤åÏûÑÌå®Îìú ÌÖåÏä§Ìä∏
            self._initialize_gamepad_with_debug()
            self.signals.piracer_status_changed.emit("PiRacer Not Available")
        
        # Î°úÍ±∞ Ìï∏Îì§Îü¨ Ï∂îÍ∞Ä
        self.logger.add_handler(self.signals.message_received.emit)
        
        # ÏãúÍ∑∏ÎÑê Ïó∞Í≤∞
        self._connect_signals()
        
    def _connect_signals(self):
        """ÏãúÍ∑∏ÎÑê Ïó∞Í≤∞"""
        signal_connections = [
            (self.signals.gear_changed, self.update_gear_display),
            (self.signals.lever_changed, self.update_lever_display),
            (self.signals.button_changed, self.update_button_display),
            (self.signals.can_status_changed, self.update_can_status),
            (self.signals.message_received, self.add_log_message),
            (self.signals.debug_info, self.add_debug_info),
            (self.signals.stats_updated, self.update_stats),
            (self.signals.speed_updated, self.update_speed_display),
            (self.signals.piracer_status_changed, self.update_piracer_status),
        ]
        
        for signal, slot in signal_connections:
            signal.connect(slot)
        
    def _init_ui(self):
        """UI Ï¥àÍ∏∞Ìôî"""
        self.setWindowTitle("BMW PiRacer Integrated Control System - GPIO16 Speed Optimized")
        self.setGeometry(0, 0, Constants.WINDOW_WIDTH, Constants.WINDOW_HEIGHT)
        
        # ÌôîÎ©¥ ÌÅ¨Í∏∞ ÏÑ§Ï†ï (1280x400 ÏµúÏ†ÅÌôî)
        self.setGeometry(0, 0, Constants.WINDOW_WIDTH, Constants.WINDOW_HEIGHT)
        self.showFullScreen()
        self.setStyleSheet(self._get_stylesheet())
        
        # ESC ÌÇ§Î°ú ÎÇòÍ∞ÄÍ∏∞ (Ïù¥ÎØ∏ importÎêú Í≤É ÏÇ¨Ïö©)
        try:
            from PyQt5.QtWidgets import QShortcut
            from PyQt5.QtGui import QKeySequence
            self.exit_shortcut = QShortcut(QKeySequence(Qt.Key_Escape), self)
            self.exit_shortcut.activated.connect(self.close)
        except:
            pass  # PyQt5 import Ïã§Ìå®Ïãú Î¨¥Ïãú
        
        # Ï§ëÏïô ÏúÑÏ†Ø
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Î©îÏù∏ Î†àÏù¥ÏïÑÏõÉ
        main_layout = QVBoxLayout()
        
        # UI Íµ¨ÏÑ± ÏöîÏÜåÎì§ (1280x400 ÏµúÏ†ÅÌôî)
        main_layout.addLayout(self._create_header())  # Ìó§Îçî: ÏïΩ 50px
        main_layout.addLayout(self._create_dashboard(), 3)  # ÎåÄÏãúÎ≥¥Îìú: ÏïΩ 200px
        main_layout.addLayout(self._create_status_panel(), 2)  # ÏÉÅÌÉú: ÏïΩ 100px
        main_layout.addWidget(self._create_log_panel(), 1)  # Î°úÍ∑∏: ÏïΩ 50px
        
        central_widget.setLayout(main_layout)
        
    def _get_stylesheet(self) -> str:
        """Ïä§ÌÉÄÏùºÏãúÌä∏ Î∞òÌôò"""
        return f"""
            QMainWindow {{
                background-color: #1a1a1a;
                color: white;
            }}
            QLabel {{
                color: white;
            }}
            QGroupBox {{
                color: white;
                border: 2px solid {Constants.BMW_BLUE};
                border-radius: 10px;
                margin-top: 10px;
                padding-top: 10px;
            }}
            QGroupBox::title {{
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }}
            QTextEdit {{
                background-color: #2d2d2d;
                color: white;
                border: 1px solid #555555;
                border-radius: 5px;
            }}
            QPushButton {{
                background-color: {Constants.BMW_BLUE};
                color: white;
                border: none;
                border-radius: 5px;
                padding: 8px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background-color: #106ebe;
            }}
            QPushButton:pressed {{
                background-color: #005a9e;
            }}
            QProgressBar {{
                border: 2px solid #555555;
                border-radius: 5px;
                text-align: center;
                background-color: #2d2d2d;
            }}
            QProgressBar::chunk {{
                background-color: {Constants.BMW_BLUE};
                border-radius: 3px;
            }}
        """
        
    def _create_header(self) -> QHBoxLayout:
        """Ìó§Îçî ÏÉùÏÑ±"""
        header_layout = QHBoxLayout()
        
        # BMW Î°úÍ≥† (ÏûëÍ≤å Ï°∞Ï†ï)
        logo_label = QLabel("üöó BMW")
        logo_label.setFont(QFont("Arial", 16, QFont.Bold))
        logo_label.setStyleSheet(f"color: {Constants.BMW_BLUE};")
        
        # ÌÉÄÏù¥ÌãÄ (ÏûëÍ≤å Ï°∞Ï†ï)
        title_label = QLabel("PiRacer Control System - GPIO16")
        title_label.setFont(QFont("Arial", 12, QFont.Bold))
        title_label.setAlignment(Qt.AlignCenter)
        
        # ÎÇòÍ∞ÄÍ∏∞ Î≤ÑÌäº
        self.exit_button = QPushButton("Exit")
        self.exit_button.setFont(QFont("Arial", 10, QFont.Bold))
        self.exit_button.setStyleSheet(f"""
            QPushButton {{
                background-color: #dc3545;
                color: white;
                border: none;
                border-radius: 5px;
                padding: 5px 15px;
                min-width: 80px;
            }}
            QPushButton:hover {{
                background-color: #c82333;
            }}
            QPushButton:pressed {{
                background-color: #bd2130;
            }}
        """)
        self.exit_button.clicked.connect(self.close)
        
        # ÏãúÍ∞Ñ
        self.time_label = QLabel(datetime.now().strftime("%H:%M:%S"))
        self.time_label.setFont(QFont("Arial", 10))
        self.time_label.setAlignment(Qt.AlignRight)
        
        # ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ ÌÉÄÏù¥Î®∏
        self.time_timer = QTimer()
        self.time_timer.timeout.connect(self._update_time)
        self.time_timer.start(1000 // Constants.TIME_UPDATE_RATE)
        
        header_layout.addWidget(logo_label)
        header_layout.addWidget(title_label, 1)
        header_layout.addWidget(self.time_label)
        header_layout.addWidget(self.exit_button)
        
        return header_layout
        
    def _create_dashboard(self) -> QHBoxLayout:
        """ÎåÄÏãúÎ≥¥Îìú ÏÉùÏÑ±"""
        dashboard_layout = QHBoxLayout()
        
        dashboard_layout.addWidget(self._create_gear_panel(), 1)
        dashboard_layout.addWidget(self._create_speed_panel(), 1)
        dashboard_layout.addWidget(self._create_piracer_panel(), 1)
        
        return dashboard_layout
        
    def _create_gear_panel(self) -> QGroupBox:
        """Í∏∞Ïñ¥ ÌëúÏãú Ìå®ÎÑê ÏÉùÏÑ±"""
        group = QGroupBox("Current Gear")
        layout = QVBoxLayout()
        
        self.gear_widget = GearDisplayWidget()
        self.gear_widget.setMinimumSize(*Constants.GEAR_DISPLAY_SIZE)
        self.gear_widget.setMaximumSize(150, 120)
        layout.addWidget(self.gear_widget)
        
        self.last_update_label = QLabel("Last Update: Never")
        self.last_update_label.setAlignment(Qt.AlignCenter)
        self.last_update_label.setFont(QFont("Arial", 10))
        layout.addWidget(self.last_update_label)
        
        group.setLayout(layout)
        return group
        
    def _create_speed_panel(self) -> QGroupBox:
        """ÏÜçÎèÑÍ≥Ñ Ìå®ÎÑê ÏÉùÏÑ±"""
        group = QGroupBox("Speedometer (GPIO16)")
        layout = QVBoxLayout()
        
        self.speedometer_widget = SpeedometerWidget()
        self.speedometer_widget.setMinimumSize(*Constants.SPEEDOMETER_SIZE)
        self.speedometer_widget.setMaximumSize(150, 150)
        layout.addWidget(self.speedometer_widget)
        
        self.speed_gear_label = QLabel("Speed Gear: 1")
        self.speed_gear_label.setAlignment(Qt.AlignCenter)
        self.speed_gear_label.setFont(QFont("Arial", 12, QFont.Bold))
        layout.addWidget(self.speed_gear_label)
        
        group.setLayout(layout)
        return group
        
    def _create_piracer_panel(self) -> QGroupBox:
        """PiRacer Ï†úÏñ¥ Ìå®ÎÑê ÏÉùÏÑ±"""
        group = QGroupBox("PiRacer Control")
        layout = QVBoxLayout()
        
        # Ïä§Î°úÌãÄ ÏßÑÌñâÎ∞î
        throttle_label = QLabel("Throttle:")
        self.throttle_bar = QProgressBar()
        self.throttle_bar.setRange(-100, 100)
        self.throttle_bar.setValue(0)
        
        # Ïä§Ìã∞Ïñ¥ÎßÅ ÏßÑÌñâÎ∞î
        steering_label = QLabel("Steering:")
        self.steering_bar = QProgressBar()
        self.steering_bar.setRange(-100, 100)
        self.steering_bar.setValue(0)
        
        # PiRacer ÏÉÅÌÉú
        self.piracer_status_label = QLabel("Status: Unknown")
        self.piracer_status_label.setFont(QFont("Arial", 10))
        
        # Í≤åÏûÑÌå®Îìú Ïû¨Ïó∞Í≤∞ Î≤ÑÌäº
        self.reconnect_gamepad_btn = QPushButton("Reconnect Gamepad")
        self.reconnect_gamepad_btn.clicked.connect(self._manual_gamepad_reconnect)
        self.reconnect_gamepad_btn.setFont(QFont("Arial", 9))
        
        layout.addWidget(throttle_label)
        layout.addWidget(self.throttle_bar)
        layout.addWidget(steering_label)
        layout.addWidget(self.steering_bar)
        layout.addWidget(self.piracer_status_label)
        layout.addWidget(self.reconnect_gamepad_btn)
        
        group.setLayout(layout)
        return group
        
    def _create_status_panel(self) -> QHBoxLayout:
        """ÏÉÅÌÉú Ìå®ÎÑê ÏÉùÏÑ±"""
        status_layout = QHBoxLayout()
        status_layout.addWidget(self._create_bmw_status_panel(), 1)
        status_layout.addWidget(self._create_system_status_panel(), 1)
        return status_layout
        
    def _create_bmw_status_panel(self) -> QGroupBox:
        """BMW ÏÉÅÌÉú Ìå®ÎÑê ÏÉùÏÑ±"""
        group = QGroupBox("BMW Lever Status")
        layout = QVBoxLayout()
        
        # Î†àÎ≤Ñ ÏúÑÏπò
        self.lever_pos_label = QLabel("Lever Position:")
        self.lever_pos_value = QLabel("Unknown")
        self.lever_pos_value.setFont(QFont("Arial", 12, QFont.Bold))
        self.lever_pos_value.setStyleSheet(f"color: {Constants.SUCCESS_GREEN};")
        
        # Î≤ÑÌäº ÏÉÅÌÉú
        self.park_btn_label = QLabel("Park Button:")
        self.park_btn_value = QLabel("Released")
        self.unlock_btn_label = QLabel("Unlock Button:")
        self.unlock_btn_value = QLabel("Released")
        
        for widget in [self.lever_pos_label, self.lever_pos_value, 
                      self.park_btn_label, self.park_btn_value,
                      self.unlock_btn_label, self.unlock_btn_value]:
            layout.addWidget(widget)
        layout.addStretch()
        
        group.setLayout(layout)
        return group
        
    def _create_system_status_panel(self) -> QGroupBox:
        """ÏãúÏä§ÌÖú ÏÉÅÌÉú Ìå®ÎÑê ÏÉùÏÑ±"""
        group = QGroupBox("System Status")
        layout = QVBoxLayout()
        
        # CAN ÏÉÅÌÉú
        self.can_status_label = QLabel("BMW CAN:")
        self.can_status_value = QLabel("Disconnected")
        self.can_status_value.setStyleSheet(f"color: {Constants.ERROR_RED};")
        
        self.speed_sensor_label = QLabel("Speed Sensor:")
        self.speed_sensor_value = QLabel("GPIO Ready")
        self.speed_sensor_value.setStyleSheet(f"color: {Constants.SUCCESS_GREEN};")
        
        # Î©îÏãúÏßÄ Ïπ¥Ïö¥ÌÑ∞
        self.msg_count_label = QLabel("Messages:")
        self.msg_count_value = QLabel("0")
        
        # Ï†úÏñ¥ Î≤ÑÌäº
        self.connect_btn = QPushButton("Connect CAN")
        self.connect_btn.clicked.connect(self._toggle_can_connection)
        
        self.clear_btn = QPushButton("Clear Logs")
        self.clear_btn.clicked.connect(self._clear_logs)
        
        for widget in [self.can_status_label, self.can_status_value,
                      self.speed_sensor_label, self.speed_sensor_value,
                      self.msg_count_label, self.msg_count_value,
                      self.connect_btn, self.clear_btn]:
            layout.addWidget(widget)
        layout.addStretch()
        
        group.setLayout(layout)
        return group
        
    def _create_log_panel(self) -> QGroupBox:
        """Î°úÍ∑∏ Ìå®ÎÑê ÏÉùÏÑ±"""
        group = QGroupBox("Real-time System Logs")
        layout = QVBoxLayout()
        
        self.log_text = QTextEdit()
        self.log_text.setMaximumHeight(40)  # Î°úÍ∑∏ ÏòÅÏó≠ Ï∂ïÏÜå
        self.log_text.setFont(QFont("Consolas", Constants.LOG_FONT_SIZE))
        
        layout.addWidget(self.log_text)
        group.setLayout(layout)
        return group
        
    def _setup_connections(self):
        """Ïó∞Í≤∞ ÏÑ§Ï†ï"""
        bmw_ok = self.can_controller.setup_can_interfaces()
        self.signals.can_status_changed.emit(bmw_ok)
        
        if bmw_ok:
            self._start_bmw_monitoring()
            self._start_led_control()
        
        # ÏÜçÎèÑÏÑºÏÑú ÏãúÏûë
        self.speed_sensor.start()
            
    def _start_control_loops(self):
        """Ï†úÏñ¥ Î£®ÌîÑ ÏãúÏûë"""
        self._start_gamepad_control()
        
    def _start_bmw_monitoring(self):
        """BMW CAN Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë"""
        def bmw_monitor_loop():
            while self.running and self.can_controller.bmw_bus:
                try:
                    msg = self.can_controller.bmw_bus.recv(timeout=Constants.BMW_CAN_TIMEOUT)
                    if msg:
                        self._bmw_message_handler(msg)
                except Exception as e:
                    if self.running:
                        self.logger.error(f"BMW CAN Error: {e}")
                        time.sleep(0.1)
        
        bmw_thread = threading.Thread(target=bmw_monitor_loop, daemon=True)
        bmw_thread.start()
    
    def _on_speed_updated(self, speed_kmh: float):
        """ÏÜçÎèÑ ÏóÖÎç∞Ïù¥Ìä∏ ÏΩúÎ∞±"""
        self.piracer_state.current_speed = speed_kmh
        self.signals.speed_updated.emit(speed_kmh)
    
    def _start_gamepad_control(self):
        """Í≤åÏûÑÌå®Îìú Ï†úÏñ¥ ÏãúÏûë"""
        self.logger.info("üöÄ Starting gamepad control system...")
        
        # ÎùºÏù¥Î∏åÎü¨Î¶¨ ÏÉÅÌÉú Ï≤¥ÌÅ¨
        self.logger.info(f"üìä Checking library availability: PIRACER_AVAILABLE={PIRACER_AVAILABLE}, GAMEPAD_CLASS={GAMEPAD_CLASS is not None}")
        
        if not PIRACER_AVAILABLE:
            self.logger.warning("‚ö†Ô∏è PiRacer library not available - trying gamepad-only mode")
            # PiRacer ÏóÜÏñ¥ÎèÑ Í≤åÏûÑÌå®ÎìúÎäî ÏãúÎèÑÌï¥Î≥º Ïàò ÏûàÏùå
            if GAMEPAD_CLASS:
                self.logger.info("üéÆ Gamepad class available - attempting gamepad-only mode")
            else:
                self.logger.error("‚ùå Neither PiRacer nor Gamepad class available - control disabled")
                return
        
        if not GAMEPAD_CLASS:
            self.logger.error("‚ùå ShanWanGamepad class not available - gamepad control disabled")
            return
        
        # PiRacer ÏÉÅÌÉú Ï≤¥ÌÅ¨
        if not self.piracer:
            self.logger.warning("‚ö†Ô∏è PiRacer hardware not available - gamepad will work in simulation mode")
            self.logger.info("üìä Gamepad inputs will be logged but not applied to hardware")
        else:
            self.logger.info("‚úÖ PiRacer hardware available - full gamepad control enabled")
            
        # Í≤åÏûÑÌå®Îìú ÏÉÅÌÉú Ï≤¥ÌÅ¨ Î∞è Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ
        if not self.gamepad:
            self.logger.warning("‚ö†Ô∏è Gamepad not available - trying to reconnect...")
            reconnect_success = self._try_gamepad_reconnect()
            if not reconnect_success:
                self.logger.error("‚ùå Gamepad reconnection failed - starting control loop anyway for monitoring")
            else:
                self.logger.info("‚úÖ Gamepad reconnection successful - control loop ready")
        else:
            self.logger.info("‚úÖ Gamepad already available - starting control loop")
        
        def gamepad_loop():
            last_l2 = last_r2 = False
            update_interval = 1.0 / Constants.GAMEPAD_UPDATE_RATE
            gamepad_error_count = 0
            max_errors = 5
            loop_count = 0
            successful_reads = 0
            
            self.logger.info(f"üéÆ Gamepad control loop started (update rate: {Constants.GAMEPAD_UPDATE_RATE}Hz)")
            self.logger.info(f"üìä Loop interval: {update_interval:.3f}s, Max errors: {max_errors}")
            
            while self.running:
                loop_count += 1
                
                # Îß§ 100ÌöåÎßàÎã§ ÏÉÅÌÉú Î°úÍ∑∏
                if loop_count % 100 == 0:
                    self.logger.info(f"üîÑ Gamepad loop #{loop_count}, successful reads: {successful_reads}, errors: {gamepad_error_count}")
                
                try:
                    # Í≤åÏûÑÌå®Îìú Ïó∞Í≤∞ Ï≤¥ÌÅ¨
                    if not self.gamepad:
                        self.logger.warning(f"üéÆ Gamepad disconnected at loop #{loop_count} - attempting reconnect...")
                        reconnect_success = self._try_gamepad_reconnect()
                        if not reconnect_success:
                            self.logger.debug(f"üîÑ Reconnection failed, waiting 1s before retry (loop #{loop_count})")
                            time.sleep(1)
                            continue
                        else:
                            self.logger.info(f"‚úÖ Reconnection successful at loop #{loop_count}")
                    
                    # Í≤åÏûÑÌå®Îìú Îç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞
                    self.logger.debug(f"üìñ Reading gamepad data (loop #{loop_count})...")
                    gamepad_input = self.gamepad.read_data()
                    successful_reads += 1
                    gamepad_error_count = 0  # ÏÑ±Í≥µÏãú ÏóêÎü¨ Ïπ¥Ïö¥Ìä∏ Î¶¨ÏÖã
                    
                    # Îß§ 50ÌöåÎßàÎã§ ÏûÖÎ†• Îç∞Ïù¥ÌÑ∞ Î°úÍπÖ
                    if loop_count % 50 == 0:
                        self.logger.info(f"üéÆ Input data: throttle={gamepad_input.analog_stick_right.y:.3f}, steering={gamepad_input.analog_stick_left.x:.3f}")
                        self.logger.info(f"üéÆ Buttons: A={gamepad_input.button_a}, B={gamepad_input.button_b}, X={gamepad_input.button_x}, Y={gamepad_input.button_y}")
                        self.logger.info(f"üéÆ Triggers: L2={gamepad_input.button_l2}, R2={gamepad_input.button_r2}")
                    
                    # ÏÜçÎèÑ Í∏∞Ïñ¥ Ï°∞Ï†à (L2/R2) - ÏÉÅÏÑ∏ Î°úÍπÖ
                    if gamepad_input.button_l2 and not last_l2:
                        old_gear = self.piracer_state.speed_gear
                        self.piracer_state.speed_gear = max(1, self.piracer_state.speed_gear - 1)
                        self.logger.info(f"üîΩ Speed Gear DOWN: {old_gear} ‚Üí {self.piracer_state.speed_gear} (L2 pressed)")
                    if gamepad_input.button_r2 and not last_r2:
                        old_gear = self.piracer_state.speed_gear
                        self.piracer_state.speed_gear = min(Constants.SPEED_GEARS, self.piracer_state.speed_gear + 1)
                        self.logger.info(f"üîº Speed Gear UP: {old_gear} ‚Üí {self.piracer_state.speed_gear} (R2 pressed)")
                    
                    # Ìä∏Î¶¨Í±∞ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                    if gamepad_input.button_l2 != last_l2:
                        self.logger.debug(f"üéÆ L2 trigger: {last_l2} ‚Üí {gamepad_input.button_l2}")
                    if gamepad_input.button_r2 != last_r2:
                        self.logger.debug(f"üéÆ R2 trigger: {last_r2} ‚Üí {gamepad_input.button_r2}")
                        
                    last_l2 = gamepad_input.button_l2
                    last_r2 = gamepad_input.button_r2
                    
                    # Ï°∞Ïù¥Ïä§Ìã± ÏûÖÎ†• with bounds checking
                    old_throttle = self.piracer_state.throttle_input
                    old_steering = self.piracer_state.steering_input
                    
                    self.piracer_state.throttle_input = -gamepad_input.analog_stick_right.y
                    self.piracer_state.steering_input = -gamepad_input.analog_stick_left.x
                    
                    # ÌÅ∞ Î≥ÄÌôîÍ∞Ä ÏûàÏùÑ ÎïåÎßå Î°úÍπÖ
                    if abs(self.piracer_state.throttle_input - old_throttle) > 0.1:
                        self.logger.debug(f"üïπÔ∏è Throttle: {old_throttle:.3f} ‚Üí {self.piracer_state.throttle_input:.3f}")
                    if abs(self.piracer_state.steering_input - old_steering) > 0.1:
                        self.logger.debug(f"üïπÔ∏è Steering: {old_steering:.3f} ‚Üí {self.piracer_state.steering_input:.3f}")
                    
                    # Í≤åÏûÑÌå®Îìú Î≤ÑÌäºÏúºÎ°ú Í∏∞Ïñ¥ Ï†úÏñ¥ (ÏÉÅÏÑ∏ Î°úÍπÖ)
                    gear_changed = False
                    old_gear = self.bmw_state.current_gear
                    
                    if gamepad_input.button_b:  # BÎ≤ÑÌäº = Drive
                        if self.bmw_state.current_gear != 'D':
                            self.bmw_state.current_gear = 'D'
                            self.logger.info(f"üéÆ Button B pressed: Gear {old_gear} ‚Üí DRIVE")
                            gear_changed = True
                    elif gamepad_input.button_a:  # AÎ≤ÑÌäº = Neutral
                        if self.bmw_state.current_gear != 'N':
                            self.bmw_state.current_gear = 'N'
                            self.logger.info(f"üéÆ Button A pressed: Gear {old_gear} ‚Üí NEUTRAL")
                            gear_changed = True
                    elif gamepad_input.button_x:  # XÎ≤ÑÌäº = Reverse
                        if self.bmw_state.current_gear != 'R':
                            self.bmw_state.current_gear = 'R'
                            self.logger.info(f"üéÆ Button X pressed: Gear {old_gear} ‚Üí REVERSE")
                            gear_changed = True
                    elif gamepad_input.button_y:  # YÎ≤ÑÌäº = Park
                        if self.bmw_state.current_gear != 'P':
                            self.bmw_state.current_gear = 'P'
                            self.logger.info(f"üéÆ Button Y pressed: Gear {old_gear} ‚Üí PARK")
                            gear_changed = True
                    
                    # Í∏∞Ïñ¥Ïóê Îî∞Î•∏ Ïä§Î°úÌãÄ Ï†úÏñ¥
                    throttle = self._calculate_throttle()
                    
                    # PiRacer Ï†úÏñ¥ (ÌïòÎìúÏõ®Ïñ¥ ÏÇ¨Ïö© Í∞ÄÎä•Ìï† ÎïåÎßå)
                    if self.piracer:
                        try:
                            self.logger.debug(f"üèéÔ∏è Applying to PiRacer: throttle={throttle:.3f}, steering={self.piracer_state.steering_input:.3f}")
                            self.piracer.set_throttle_percent(throttle)
                            self.piracer.set_steering_percent(self.piracer_state.steering_input)
                        except Exception as piracer_error:
                            self.logger.error(f"‚ùå PiRacer control error: {piracer_error}")
                    else:
                        # ÏãúÎÆ¨Î†àÏù¥ÏÖò Î™®Îìú Î°úÍπÖ
                        if loop_count % 100 == 0:  # 100Î≤àÎßàÎã§ Î°úÍπÖ
                            self.logger.info(f"üñ•Ô∏è SIMULATION: throttle={throttle:.3f}, steering={self.piracer_state.steering_input:.3f}, gear={self.bmw_state.current_gear}")
                    
                    # Í∏∞Ïñ¥ ÏÉÅÌÉú UI ÏóÖÎç∞Ïù¥Ìä∏ (Î≥ÄÍ≤ΩÏãúÏóêÎßå)
                    if gear_changed:
                        self.logger.debug(f"üîÑ Updating UI for gear change: {self.bmw_state.current_gear}")
                        self.signals.gear_changed.emit(self.bmw_state.current_gear)
                    
                    # UI ÏóÖÎç∞Ïù¥Ìä∏
                    try:
                        self.throttle_bar.setValue(int(throttle * 100))
                        self.steering_bar.setValue(int(self.piracer_state.steering_input * 100))
                    except Exception as ui_error:
                        self.logger.error(f"‚ùå UI update error: {ui_error}")
                    
                    time.sleep(update_interval)
                    
                except Exception as e:
                    gamepad_error_count += 1
                    self.logger.error(f"üéÆ Gamepad Error #{gamepad_error_count} at loop #{loop_count}: {e}")
                    self.logger.error(f"üîç Error type: {type(e).__name__}")
                    
                    # ÏÉÅÏÑ∏Ìïú ÏóêÎü¨ Ï†ïÎ≥¥
                    if gamepad_error_count <= 3:  # Ï≤òÏùå 3Î≤à ÏóêÎü¨Îßå ÏÉÅÏÑ∏ Î°úÍπÖ
                        import traceback
                        self.logger.error(f"üìã Error traceback:\n{traceback.format_exc()}")
                    
                    if gamepad_error_count >= max_errors:
                        self.logger.critical(f"üéÆ CRITICAL: Too many gamepad errors ({gamepad_error_count}), disconnecting and trying reconnect...")
                        self.logger.critical(f"üìä Success rate before disconnect: {successful_reads}/{loop_count} ({100*successful_reads/loop_count:.1f}%)")
                        self.gamepad = None
                        gamepad_error_count = 0
                        # Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ Ï†Ñ Ïû†Ïãú ÎåÄÍ∏∞
                        self.logger.info("‚è≥ Waiting 2 seconds before reconnection attempt...")
                        time.sleep(2)
                    else:
                        time.sleep(1)
        
        gamepad_thread = threading.Thread(target=gamepad_loop, daemon=True)
        gamepad_thread.start()
    
    def _initialize_gamepad_with_debug(self):
        """ÏÉÅÏÑ∏Ìïú ÎîîÎ≤ÑÍπÖÏùÑ Ìè¨Ìï®Ìïú Í≤åÏûÑÌå®Îìú Ï¥àÍ∏∞Ìôî"""
        self.logger.info("üîç Starting detailed gamepad initialization...")
        
        # USB ÎîîÎ∞îÏù¥Ïä§ Í≤ÄÏÇ¨
        try:
            import subprocess
            result = subprocess.run(['lsusb'], capture_output=True, text=True)
            self.logger.info(f"üì± USB devices detected:\n{result.stdout}")
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è Could not check USB devices: {e}")
        
        # Í≤åÏûÑÌå®Îìú ÎîîÎ∞îÏù¥Ïä§ ÌååÏùº Í≤ÄÏÇ¨
        import os
        js_devices = []
        for i in range(10):  # /dev/input/js0 ~ js9 Í≤ÄÏÇ¨
            js_path = f"/dev/input/js{i}"
            if os.path.exists(js_path):
                js_devices.append(js_path)
        
        if js_devices:
            self.logger.info(f"üéÆ Joystick devices found: {js_devices}")
        else:
            self.logger.warning("‚ö†Ô∏è No joystick devices found in /dev/input/")
        
        # Ïù¥Î≤§Ìä∏ ÎîîÎ∞îÏù¥Ïä§ Í≤ÄÏÇ¨
        event_devices = []
        for i in range(20):  # /dev/input/event0 ~ event19 Í≤ÄÏÇ¨
            event_path = f"/dev/input/event{i}"
            if os.path.exists(event_path):
                event_devices.append(event_path)
        
        if event_devices:
            self.logger.info(f"üì° Input event devices found: {event_devices}")
        else:
            self.logger.warning("‚ö†Ô∏è No input event devices found")
        
        # ShanWanGamepad Ï¥àÍ∏∞Ìôî ÏãúÎèÑ
        try:
            if not GAMEPAD_CLASS:
                raise ImportError("ShanWanGamepad class not available - PiRacer library not imported")
                
            self.logger.info("üéÆ Attempting ShanWanGamepad initialization...")
            self.gamepad = GAMEPAD_CLASS()
            self.logger.info("‚úÖ ShanWanGamepad initialized successfully!")
            
            # Í≤åÏûÑÌå®Îìú ÌÖåÏä§Ìä∏ ÏùΩÍ∏∞
            try:
                self.logger.info("üß™ Testing gamepad input reading...")
                test_data = self.gamepad.read_data()
                self.logger.info(f"üìä Gamepad test data: {test_data}")
                self.logger.info("‚úÖ Gamepad input reading test successful")
                self.signals.piracer_status_changed.emit("Gamepad Connected & Tested")
            except Exception as read_error:
                self.logger.error(f"‚ùå Gamepad read test failed: {read_error}")
                self.logger.error(f"üîç Read error type: {type(read_error).__name__}")
                self.signals.piracer_status_changed.emit(f"Gamepad Connected, Read Error: {read_error}")
                
        except Exception as e:
            self.logger.critical(f"‚ùå CRITICAL: ShanWanGamepad initialization failed: {e}")
            self.logger.error(f"üîç Error type: {type(e).__name__}")
            self.logger.error(f"üîç Error args: {e.args}")
            
            # ÏÉÅÏÑ∏Ìïú ÏòàÏô∏ Ï†ïÎ≥¥
            import traceback
            self.logger.critical(f"üìã Full initialization traceback:\n{traceback.format_exc()}")
            
            self.gamepad = None
            self.signals.piracer_status_changed.emit(f"Gamepad Error: {e}")
    
    def _try_gamepad_reconnect(self):
        """Í≤åÏûÑÌå®Îìú Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ"""
        self.logger.info("üîÑ Starting gamepad reconnection attempt...")
        
        if not PIRACER_AVAILABLE:
            self.logger.warning("‚ö†Ô∏è PiRacer library not available for reconnection")
            # PiRacer ÏóÜÏñ¥ÎèÑ Í≤åÏûÑÌå®ÎìúÎäî ÏãúÎèÑ
        
        try:
            self.logger.info("üéÆ Attempting gamepad reconnection...")
            
            # Ïó∞Í≤∞ Í∞ÄÎä•ÏÑ± Í≤ÄÏÇ¨
            if not PIRACER_AVAILABLE or not GAMEPAD_CLASS:
                raise ImportError("PiRacer library or ShanWanGamepad class not available")
            
            # Í∏∞Ï°¥ Í≤åÏûÑÌå®Îìú Ï†ïÎ¶¨
            if self.gamepad:
                self.logger.info("üßπ Cleaning up existing gamepad connection...")
                self.gamepad = None
            
            # ÏÉàÎ°úÏö¥ Ïó∞Í≤∞ ÏãúÎèÑ
            self.gamepad = GAMEPAD_CLASS()
            self.logger.info("‚úÖ Gamepad reconnected successfully")
            
            # Ïû¨Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
            try:
                test_data = self.gamepad.read_data()
                self.logger.info(f"üß™ Reconnection test successful: {test_data}")
                self.signals.piracer_status_changed.emit("Gamepad Reconnected & Tested")
                return True
            except Exception as test_error:
                self.logger.error(f"‚ùå Reconnection test failed: {test_error}")
                self.signals.piracer_status_changed.emit(f"Reconnected, Test Failed: {test_error}")
                return False
                
        except Exception as e:
            self.logger.critical(f"‚ùå CRITICAL: Gamepad reconnection failed: {e}")
            self.logger.error(f"üîç Reconnection error type: {type(e).__name__}")
            import traceback
            self.logger.critical(f"üìã Reconnection traceback:\n{traceback.format_exc()}")
            
            self.gamepad = None
            self.signals.piracer_status_changed.emit(f"Reconnection Failed: {e}")
            return False
    
    def _manual_gamepad_reconnect(self):
        """ÏàòÎèô Í≤åÏûÑÌå®Îìú Ïû¨Ïó∞Í≤∞"""
        self.logger.info("üîÑ Manual gamepad reconnection requested...")
        if self._try_gamepad_reconnect():
            self.logger.info("‚úÖ Manual gamepad reconnection successful")
        else:
            self.logger.error("‚ùå Manual gamepad reconnection failed")
    
    def _calculate_throttle(self) -> float:
        """Ïä§Î°úÌãÄ Í≥ÑÏÇ∞"""
        speed_limit = self.piracer_state.speed_gear * 0.25
        
        if self.bmw_state.current_gear == 'D':
            throttle = min(0.0, self.piracer_state.throttle_input)  # Ï†ÑÏßÑÎßå
        elif self.bmw_state.current_gear == 'R':
            throttle = max(0.0, self.piracer_state.throttle_input)  # ÌõÑÏßÑÎßå
        else:
            throttle = 0.0  # P, NÏóêÏÑúÎäî Ï†ïÏßÄ
        
        return throttle * speed_limit
    
    def _start_led_control(self):
        """LED Ï†úÏñ¥ ÏãúÏûë"""
        def led_control_loop():
            update_interval = 1.0 / Constants.LED_UPDATE_RATE
            
            while self.running and self.can_controller.bmw_bus:
                if self.bmw_state.current_gear != 'Unknown':
                    self.can_controller.send_gear_led(self.bmw_state.current_gear, flash=False)
                time.sleep(update_interval)
        
        if self.can_controller.bmw_bus:
            led_thread = threading.Thread(target=led_control_loop, daemon=True)
            led_thread.start()
    
    def _bmw_message_handler(self, msg: can.Message):
        """BMW CAN Î©îÏãúÏßÄ Ìï∏Îì§Îü¨"""
        self.message_count += 1
        self.signals.stats_updated.emit(self.message_count)
        
        if msg.arbitration_id == Constants.LEVER_MESSAGE_ID:
            # BMW Í∏∞Ïñ¥ Î†àÎ≤Ñ Î©îÏãúÏßÄ
            if self.lever_controller.decode_lever_message(msg, self.bmw_state):
                # UI ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÍ∑∏ÎÑê Î∞©Ï∂ú
                self.signals.lever_changed.emit(self.bmw_state.lever_position)
                self.signals.button_changed.emit(self.bmw_state.park_button, self.bmw_state.unlock_button)
                self.signals.gear_changed.emit(self.bmw_state.current_gear)
                
                # Í∏∞Ïñ¥ Î≥ÄÍ≤ΩÏãú LED ÏóÖÎç∞Ïù¥Ìä∏
                if self.bmw_state.current_gear != 'Unknown':
                    self.can_controller.send_gear_led(self.bmw_state.current_gear, flash=False)
    
    # UI ÏóÖÎç∞Ïù¥Ìä∏ Î©îÏÑúÎìúÎì§
    def _update_time(self):
        """ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏"""
        self.time_label.setText(datetime.now().strftime("%H:%M:%S"))
    
    def update_gear_display(self, gear: str):
        """Í∏∞Ïñ¥ ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏"""
        self.gear_widget.set_gear(gear, self.bmw_state.manual_gear)
        if self.bmw_state.last_update:
            self.last_update_label.setText(f"Last Update: {self.bmw_state.last_update}")
    
    def update_lever_display(self, lever_pos: str):
        """Î†àÎ≤Ñ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏"""
        self.lever_pos_value.setText(lever_pos)
    
    def update_button_display(self, park_btn: str, unlock_btn: str):
        """Î≤ÑÌäº ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏"""
        self.park_btn_value.setText(park_btn)
        self.unlock_btn_value.setText(unlock_btn)
        
        park_color = "#ff4444" if park_btn == "Pressed" else "#44ff44"
        unlock_color = "#ff4444" if unlock_btn == "Pressed" else "#44ff44"
        
        self.park_btn_value.setStyleSheet(f"color: {park_color};")
        self.unlock_btn_value.setStyleSheet(f"color: {unlock_color};")
    
    def update_can_status(self, connected: bool):
        """CAN ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏"""
        if connected:
            self.can_status_value.setText("Connected")
            self.can_status_value.setStyleSheet(f"color: {Constants.SUCCESS_GREEN};")
        else:
            self.can_status_value.setText("Disconnected")
            self.can_status_value.setStyleSheet(f"color: {Constants.ERROR_RED};")
    
    def update_speed_display(self, speed: float):
        """ÏÜçÎèÑ ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏"""
        self.speedometer_widget.set_speed(speed)
        self.speed_gear_label.setText(f"Speed Gear: {self.piracer_state.speed_gear}")
    
    def update_piracer_status(self, status: str):
        """PiRacer ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏"""
        self.piracer_status_label.setText(f"Status: {status}")
    
    def update_stats(self, count: int):
        """ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏"""
        self.msg_count_value.setText(str(count))
    
    def add_log_message(self, message: str):
        """Î°úÍ∑∏ Î©îÏãúÏßÄ Ï∂îÍ∞Ä"""
        timestamp = datetime.now().strftime("[%H:%M:%S]")
        self.log_text.append(f"{timestamp} {message}")
        
        # Î°úÍ∑∏Í∞Ä ÎÑàÎ¨¥ ÎßéÏïÑÏßÄÎ©¥ ÏÉÅÎã® Ï†úÍ±∞
        if self.log_text.document().blockCount() > Constants.MAX_LOG_LINES:
            cursor = self.log_text.textCursor()
            cursor.movePosition(cursor.Start)
            cursor.select(cursor.BlockUnderCursor)
            cursor.removeSelectedText()
    
    def add_debug_info(self, debug_msg: str):
        """ÎîîÎ≤ÑÍ∑∏ Ï†ïÎ≥¥ Ï∂îÍ∞Ä"""
        self.add_log_message(debug_msg)
    
    def _clear_logs(self):
        """Î°úÍ∑∏ ÏßÄÏö∞Í∏∞"""
        self.log_text.clear()
        self.logger.info("üßπ Logs cleared")
    
    def _toggle_can_connection(self):
        """CAN Ïó∞Í≤∞ ÌÜ†Í∏Ä"""
        self._clear_logs()
        self.logger.info("üîÑ Reconnecting CAN interfaces...")
        self._setup_connections()
    
    def closeEvent(self, event):
        """ÌîÑÎ°úÍ∑∏Îû® Ï¢ÖÎ£å Ïãú"""
        self.logger.info("üõë BMW PiRacer Controller shutting down...")
        self.logger.critical("üî¥ SESSION END - Application closed by user")
        
        self.running = False
        self.can_controller.shutdown()
        self.speed_sensor.cleanup()
        
        # Î°úÍ∑∏ ÌååÏùº ÏúÑÏπò ÏïàÎÇ¥
        log_filename = self.logger.get_log_filename()
        if log_filename:
            print(f"üìù Complete log saved to: {log_filename}")
        
        event.accept()

def setup_can_interfaces():
    """CAN Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ ÏÑ§Ï†ï (BMW CANÎßå)"""
    print("üîß Setting up BMW CAN interface...")
    
    # BMW CAN (can0) ÏÑ§Ï†ï
    result_down = os.system(f"sudo ip link set {Constants.BMW_CAN_CHANNEL} down 2>/dev/null")
    result_up = os.system(f"sudo ip link set {Constants.BMW_CAN_CHANNEL} up type can bitrate {Constants.CAN_BITRATE} 2>/dev/null")
    
    if result_up == 0:
        print(f"‚úì BMW CAN interface ({Constants.BMW_CAN_CHANNEL}) configured successfully")
    else:
        print(f"‚ö† Failed to configure BMW CAN interface ({Constants.BMW_CAN_CHANNEL})")

def main():
    """Î©îÏù∏ Ìï®Ïàò"""
    # Ïã§Ìñâ ÏãúÏûë Î°úÍπÖ
    start_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    print(f"üöÄ BMW PiRacer Controller starting at {start_time}")
    print(f"üìÅ Working directory: {os.getcwd()}")
    print(f"üìù Logs will be saved to: logs/bmw_controller_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log")
    
    # DISPLAY ÌôòÍ≤ΩÎ≥ÄÏàò ÏûêÎèô ÏÑ§Ï†ï
    if not os.environ.get('DISPLAY'):
        os.environ['DISPLAY'] = ':0'
        print("üñ•Ô∏è DISPLAY ÌôòÍ≤ΩÎ≥ÄÏàòÎ•º ÏûêÎèôÏúºÎ°ú ÏÑ§Ï†ïÌñàÏäµÎãàÎã§: :0")
    
    # ÏãúÏûë Î©îÏãúÏßÄ
    features = [
        "- BMW Gear Lever Control (P/R/N/D/M1-M8)",
        "- Gamepad Throttle/Steering Control", 
        "- Real-time Speed Display via GPIO16",
        "- BMW CAN Bus + GPIO16 Speed Sensor",
        "- Optimized Performance & Code Quality"
    ]
    
    print("üöÄ BMW PiRacer Integrated Control System Started - GPIO Speed Optimized")
    print("Features:")
    for feature in features:
        print(feature)
    
    # ÎîîÏä§ÌîåÎ†àÏù¥ Ï≤¥ÌÅ¨ (ÏûêÎèô ÏÑ§Ï†ï ÌõÑ)
    display_available = os.environ.get('DISPLAY') is not None
    
    if PYQT5_AVAILABLE and display_available:
        features.append("- Integrated PyQt5 Dashboard")
        print("üé® Launching PyQt5 GUI...")
        try:
            # QApplication ÏïàÏ†Ñ Ï¥àÍ∏∞Ìôî
            app = QApplication.instance()
            if app is None:
                app = QApplication(sys.argv)
            
            # ÌîåÎû´Ìèº ÌôïÏù∏
            print(f"üîç Qt platform: {app.platformName()}")
            
            # CAN Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ ÏûêÎèô ÏÑ§Ï†ï
            setup_can_interfaces()
            
            # Î©îÏù∏ ÏúàÎèÑÏö∞ ÏÉùÏÑ±
            print("üèóÔ∏è Creating main window...")
            window = BMWPiRacerIntegratedControl()
            
            # ÏïàÏ†ÑÌïú ÏúàÎèÑÏö∞ ÌëúÏãú
            print("üåü Showing GUI window...")
            window.show()
            
            # Qt Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨ ÎåÄÍ∏∞
            app.processEvents()
            
            print("‚úÖ GUI launched successfully!")
            
            # ÏïàÏ†ÑÌïú Ïù¥Î≤§Ìä∏ Î£®ÌîÑ
            exit_code = app.exec_()
            sys.exit(exit_code)
        except Exception as e:
            print(f"‚ùå GUI launch failed: {e}")
            print(f"üîç Error type: {type(e).__name__}")
            import traceback
            print(f"üìã GUI Error traceback:\n{traceback.format_exc()}")
            print("üí° Running in headless mode instead...")
    elif PYQT5_AVAILABLE and not display_available:
        print("‚ö†Ô∏è PyQt5 available but no display detected (DISPLAY environment variable not set)")
        print("üí° To run with GUI:")
        print("   - Connect a monitor and run: DISPLAY=:0 python3 bmw_piracer_integrated_control_optimized.py")
        print("   - Or use VNC/X11 forwarding")
        print("üí° Running in headless mode...")
    else:
        print("‚ö†Ô∏è Running in headless mode without GUI")
        print("‚ö†Ô∏è Install PyQt5 to enable the dashboard: pip install PyQt5")
        
        # CAN Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ ÏûêÎèô ÏÑ§Ï†ï
        setup_can_interfaces()
        
        # Ìó§ÎìúÎ¶¨Ïä§ Î™®ÎìúÎ°ú Ïã§Ìñâ
        try:
            # Í∞ÑÎã®Ìïú CAN Î™®ÎãàÌÑ∞ÎßÅÎßå Ïã§Ìñâ
            import can
            bus = can.interface.Bus(channel='can0', interface='socketcan')
            print("üöÄ Headless mode: Monitoring CAN messages... (Press Ctrl+C to exit)")
            
            while True:
                msg = bus.recv(timeout=1.0)
                if msg and msg.arbitration_id == 0x197:  # BMW lever message
                    print(f"üì® BMW Lever Message: {msg}")
                    
        except KeyboardInterrupt:
            print("\nüõë Shutting down...")
        except Exception as e:
            print(f"‚ùå Error in headless mode: {e}")
            print(f"üîç Error type: {type(e).__name__}")
            import traceback
            print(f"üìã Headless Error traceback:\n{traceback.format_exc()}")
            print("üí° Make sure CAN interface is properly configured")
        
        sys.exit(0)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nüõë Program interrupted by user (Ctrl+C)")
        end_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        print(f"üî¥ Session ended at {end_time}")
    except Exception as e:
        print(f"\n‚ùå CRITICAL ERROR in main(): {e}")
        print(f"üîç Error type: {type(e).__name__}")
        import traceback
        print(f"üìã Critical traceback:\n{traceback.format_exc()}")
        end_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        print(f"üõë Session crashed at {end_time}")
        sys.exit(1)